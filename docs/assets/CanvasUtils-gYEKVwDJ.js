import{h as P}from"./index-U8ylzn9J.js";const f={x:0,y:0};function W(r,t,a){r.beginPath(),r.moveTo(t.x,t.y),r.lineTo(a.x,a.y),r.closePath()}function T(r,t,a){r.fillStyle=a??"rgba(0,0,0,0)",r.fillRect(f.x,f.y,t.width,t.height)}function A(r,t,a,e){a&&(r.globalAlpha=e,r.drawImage(a,f.x,f.y,t.width,t.height),r.globalAlpha=1)}function O(r,t){r.clearRect(f.x,f.y,t.width,t.height)}async function v(r){const{container:t,context:a,particle:e,delta:s,colorStyles:i,backgroundMask:n,composite:l,radius:o,opacity:u,shadow:c,transform:h}=r,g=e.getPosition(),x=0,m=e.rotation+(e.pathRotation?e.velocity.angle:x),w={sin:Math.sin(m),cos:Math.cos(m)},p=1,d={a:w.cos*(h.a??p),b:w.sin*(h.b??p),c:-w.sin*(h.c??p),d:w.cos*(h.d??p)};a.setTransform(d.a,d.b,d.c,d.d,g.x,g.y),n&&(a.globalCompositeOperation=l);const D=e.shadowColor;c.enable&&D&&(a.shadowBlur=c.blur,a.shadowColor=P(D),a.shadowOffsetX=c.offset.x,a.shadowOffsetY=c.offset.y),i.fill&&(a.fillStyle=i.fill);const k=0,b=e.strokeWidth??k;a.lineWidth=b,i.stroke&&(a.strokeStyle=i.stroke);const y={container:t,context:a,particle:e,radius:o,opacity:u,delta:s,transformData:d,strokeWidth:b};await S(y),await C(y),await R(y),a.globalCompositeOperation="source-over",a.resetTransform()}async function R(r){const{container:t,context:a,particle:e,radius:s,opacity:i,delta:n,transformData:l}=r;if(!e.effect)return;const o=t.effectDrawers.get(e.effect);o&&await o.draw({context:a,particle:e,radius:s,opacity:i,delta:n,pixelRatio:t.retina.pixelRatio,transformData:{...l}})}async function S(r){const{container:t,context:a,particle:e,radius:s,opacity:i,delta:n,strokeWidth:l,transformData:o}=r,u=0;if(!e.shape)return;const c=t.shapeDrawers.get(e.shape);c&&(a.beginPath(),await c.draw({context:a,particle:e,radius:s,opacity:i,delta:n,pixelRatio:t.retina.pixelRatio,transformData:{...o}}),e.shapeClose&&a.closePath(),l>u&&a.stroke(),e.shapeFill&&a.fill())}async function C(r){const{container:t,context:a,particle:e,radius:s,opacity:i,delta:n,transformData:l}=r;if(!e.shape)return;const o=t.shapeDrawers.get(e.shape);o!=null&&o.afterDraw&&await o.afterDraw({context:a,particle:e,radius:s,opacity:i,delta:n,pixelRatio:t.retina.pixelRatio,transformData:{...l}})}async function M(r,t,a){t.draw&&await t.draw(r,a)}async function B(r,t,a,e){t.drawParticle&&await t.drawParticle(r,a,e)}function I(r,t,a){return{h:r.h,s:r.s,l:r.l+(t==="darken"?-1:1)*a}}export{A as a,B as b,O as c,v as d,M as e,I as f,W as g,T as p};
